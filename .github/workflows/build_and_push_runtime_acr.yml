name: Build & push runtime image to ACR (cloud build)

on:
  workflow_dispatch:

jobs:
  acr-build:
    name: ACR Build (uses Azure OIDC or AZURE credentials)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure with OIDC (preferred)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Ensure subscription and verify ACR
        run: |
          # Make sure we operate in the expected subscription
          if [ -n "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            echo "Using subscription: $(az account show --query '{name:name, id:id}' -o tsv)"
          fi

          # Verify the ACR exists before trying to build
          if ! az acr show --name "${{ secrets.ACR_NAME }}" >/dev/null 2>&1; then
            echo "ERROR: ACR '${{ secrets.ACR_NAME }}' not found in subscription '${{ secrets.AZURE_SUBSCRIPTION_ID }}'." >&2
            echo "Make sure you set the repository secret ACR_NAME to the actual registry name (e.g. ragfoundationsdemoregistry)." >&2
            exit 1
          fi

      - name: ACR build (build in Azure, no large push from runner)
        run: |
          az acr build --registry ${{ secrets.ACR_NAME }} --image rag_ai_backend:runtime-minimal -f Dockerfile.runtime .

      - name: Update App Service to use ACR image (optional)
        if: ${{ secrets.AZURE_APP_NAME != '' }}
        run: |
          # Determine registry login server (prefer explicit ACR_LOGIN_SERVER secret)
          if [ -n "${{ secrets.ACR_LOGIN_SERVER }}" ]; then
            REGISTRY=${{ secrets.ACR_LOGIN_SERVER }}
          else
            echo "ACR_LOGIN_SERVER not set, resolving from ACR_NAME '${{ secrets.ACR_NAME }}'"
            REGISTRY=$(az acr show --name "${{ secrets.ACR_NAME }}" --query loginServer -o tsv)
          fi

          IMAGE="$REGISTRY/rag_ai_backend:runtime-minimal"
          echo "Updating App Service '${{ secrets.AZURE_APP_NAME }}' to use image: $IMAGE"

          az webapp config container set \
            --name "${{ secrets.AZURE_APP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --docker-custom-image-name "$IMAGE" \
            --docker-registry-server-url "https://$REGISTRY"

          # Ensure the app serves on port 8000 (matches the Dockerfile.runtime)
          az webapp config appsettings set \
            --name "${{ secrets.AZURE_APP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --settings WEBSITES_PORT=8000

          # Restart and show status + hostname
          az webapp restart --name "${{ secrets.AZURE_APP_NAME }}" --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo "Waiting for webapp to report 'Running' state..."
          for i in {1..12}; do
            sleep 5
            STATE=$(az webapp show --name "${{ secrets.AZURE_APP_NAME }}" --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" --query state -o tsv)
            if [ "$STATE" = "Running" ]; then
              echo "App is Running"
              break
            fi
            echo "Current state: $STATE - retrying..."
          done

          echo "Web app info:"
          az webapp show --name "${{ secrets.AZURE_APP_NAME }}" --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" --query "{defaultHostName:defaultHostName,state:state}" -o table
